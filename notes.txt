assumed background:
    - shared references and mutable references (chapter 4)
    - Result and unwrap (chapter 9)
    - traits and generic functions (chapter 10)
    - Drop (chapter 15)
    - overlap with the multithreaded webserver in chapter 20
magic happening
    - Arc
        - `number` and `alias` are the same object
        - exactly like C++ shared_ptr
        - kind of like Python
    - thread::spawn
        - FnOnce/FnMut/Fn
            - self vs &mut self vs &self
        - 'static
            - move keyword is required
            - EXAMPLE getting rid of the Arc doesn't work
        - Send
            - Rc doesn't work
    - Deref/DerefMut
        - Deref in println and DerefMut with the += operator
            - MutexGuard docs
            - int_holder.rs
        - .lock()
            - EXAMPLE getting rid of the Mutex doesn't work
        - add_loop()
            - Contrived here, but common as &String -> &str.
alternatives
    - EXAMPLE global Mutex, non-const function error
    - EXAMPLE unsafe global Mutex with MaybeUninit
    - EXAMPLE safe global Mutex with once_cell::sync::Lazy
        - https://doc.rust-lang.org/std/lazy/struct.SyncLazy.html
    - EXAMPLE crossbeam::scope also works
        - https://doc.rust-lang.org/std/thread/fn.scope.html
    - can we get rid of the Mutex?
        - EXAMPLE unsafe static mut
        - EXAMPLE atomics
language tradeoffs
    - Stroustrup's Rule
    - invisible derefs, FnMut, Send
    - destructors
    - the .unwrap() after .lock()
